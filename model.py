from magenta.models.performance_rnn import performance_sequence_generator
from magenta.models.shared import sequence_generator_bundle
from magenta.models.performance_rnn import performance_model

from note_seq.protobuf import generator_pb2
from note_seq.protobuf import music_pb2
from note_seq import midi_io
import note_seq  #https://github.com/magenta/note-seq
import os
import ast # abstract syntax trees

def generate_sequence(selected_model="performance", midi_file=None):
    # midi_file = "chopin_nocturne.mid" #TODO enable uploads of midi files or use defaults

    if midi_file:
        cmd = f"""
        performance_rnn_generate \
        --config="{selected_model}" \
        --bundle_file="./models/{selected_model}.mag" \
        --output_dir="./generated" \
        --num_outputs=1 \
        --num_steps=1000 \ 
        --primer_pitches="./midi_files/{midi_file}
    
        """ # TODO: play around with outputs files

    os.system(cmd)

    if


def old_generate_sequence(selected_model, temp = 0.9):

    # downloaded mag files from here
    # https://github.com/magenta/magenta/tree/master/magenta/models/performance_rnn
    BUNDLE_DIR = './models/'
    MODEL_NAME = selected_model # stored in models folder
    # one of
    # these models have different embedding representations
    # performance - ignores note velocities but models note on/off events with expressive timing
    # performance_with_dynamics - model includes velocity changes quantized into 32 bins
    # performance_with_dynamics_and_modulo_encoding - model uses an alternate encoding where event values are mapped to points on the unit circle.
    # conditional models with desired density, pitch or both.
    # density_conditioned_performance_with_dynamics
    # pitch_conditioned_performance_with_dynamics
    # multiconditioned_performance_with_dynamics
    BUNDLE_NAME = MODEL_NAME + '.mag'

    bundle = sequence_generator_bundle.read_bundle_file(os.path.join(BUNDLE_DIR, BUNDLE_NAME))

    generator_map = performance_sequence_generator.get_generator_map()
    generator = generator_map[MODEL_NAME](checkpoint=None, bundle=bundle)
    generator.initialize()
    generator_options = generator_pb2.GeneratorOptions()
    generator_options.args['temperature'].float_value = temp  # Higher is more random; 1.0 is default. Try 0.9 to 2.0
    generate_section = generator_options.generate_sections.add(start_time=0, end_time=30)

    #init_seq = music_pb2.NoteSequence()
    primer_melody = note_seq.Melody(ast.literal_eval("[60,62,64,65,67,69,71,72]"))
    primer_sequence = primer_melody.to_sequence()

    generate_section = generator_options.generate_sections.add(
        start_time=primer_sequence.total_time,
        end_time=generate_end_time)

    sequence = generator.generate(primer_sequence, generator_options) # magic , log likelihood -3794.191895

    midi_io.note_sequence_to_midi_file(init_seq,'./midi_files/init_seq.mid')
    midi_io.note_sequence_to_midi_file(sequence, './midi_files/gen_seq.mid')

    return sequence



seq = generate_sequence('performance', temp = 0.9)
seq2 = generator.generate(seq, generator_options) # magic , log likelihood -3794.191895


def make_music(model, details, input_seq, generator_options):
    """

    :param model: instance of Performance Rnn Model
    :param details: Generator details for the Performance Rnn model
    :param input_seq: input sequence generated by the user (type unsure??) # todo
    :param generator_options: Options to use for the generation

    :return: generated sequence (type unsure??) #todo

    reference: https://colab.research.google.com/notebooks/magenta/performance_rnn/performance_rnn.ipynb
    """



    performance_sequence_generator(model, # an instance of PerformanceRnnModel # todo: what types of models are there?
                                   details, # generator_pb2.GeneratorDetails for this generator
                                   steps_per_second=100,
                                   num_velocity_bins=0,
                                   control_signals=None,
                                   optional_conditioning=False,
                                   max_note_duration=5.0, # force forget of notes by setting this
                                   fill_generate_section=True, # sequence length determined not estimated
                                   checkpoint=None, #
                                   bundle=None,
                                   note_performance=False)

    note_sequence_proto = performance_sequence_generator.generate(input_seq, generator_options)